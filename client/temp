#! /usr/bin/env python3

from tkinter import *
import socket
import threading
from Parser import packet_parser

username = "hem1t"
user_list = {}


def remove_user(user):
    user_list.pop(user)


def add_user(user, address):
    user_list[user] = address[0]


def process_request_dict(data, method):
    print("inside")
    if method == "chat":
        print("lskdjf")
        insert_chat(data['u'], data['t'])
        print("asdfasdf")
    elif method == "remove":
        remove_user(data['u'])


def listener(socks):
        while True:
            print("listener")
            sock_client, address = socks.accept()
            data = sock_client.recv(1024 * 1024).decode()
            data, methods = packet_parser(data)
            print(data)
            print(":" + methods + ":")
            if data.__len__() > 0:
                add_user(data['u'], address)
                process_request_dict(data, methods)


def get_size(wroot):
    print(wroot.winfo_width())
    print(wroot.winfo_height())


class ConnectApp:
    def __init__(self, master):
        self.master = master
        self.ip_value = StringVar()
        self.ip_label = Label(master, text="IP Address")
        self.ip_entry = Entry(master, textvariable=self.ip_value)
        self.connect_button = Button(master, text="Connect", command=self.connect_button_run)
        self.ip_label.grid(row=0)
        self.ip_entry.grid(row=0, column=1)
        self.connect_button.grid(row=1, columnspan=2, pady=2)

    def connect_button_run(self):
        self.master.destroy()


def open_connect():
    connect_wn = Tk()
    connect_app_wn = ConnectApp(connect_wn)
    connect_wn.mainloop()


def input_chat(event):
    global username, chat_label, chat_text
    chat_label.config(state=NORMAL)
    chat_label.insert(END, "\n" + username + ": " + chat_text.get())
    chat_label.config(state=DISABLED)
    chat_text.set("")


def insert_chat(other_username, text):
    global chat_label
    if text[0] == "@":
        user = text[1:text.index(" ")]
        global user_list
        address = user_list[user]
        send(text, address)
    else:
        sendall(text)
    print("in")
    chat_label.config(state=NORMAL)
    print("should be their now")
    chat_label.insert(INSERT, "\n" + other_username + ": " + text)
    chat_label.config(state=DISABLED)


def send(text, address):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((address, 5555))
    sock.send(bytes("chat{t:" + text + ",u:" + username + ",}", 'utf-8'))
    sock.close()


def sendall(text):
    global user_list
    for user in user_list.keys():
        send(text, user_list[user])


if __name__ == "__main__":
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(("0.0.0.0", 5555))
    sock.listen(5)
    root = Tk()
    root.title("ToTalk")
    root.minsize(800, 405)
    root.maxsize(805, 437)
    frame_list = Frame(root, height=20, width=15)
    label_list = Text(frame_list, bg="white", width=15)
    label_list.pack(side=LEFT, fill=Y)
    scroll_list = Scrollbar(frame_list)
    scroll_list.pack(side=RIGHT, fill=Y)
    scroll_list.config(command=label_list.yview)
    label_list.config(yscrollcommand=scroll_list.set)
    label_list.config(state=DISABLED)
    frame_list.pack(side=LEFT)
    # Frame CHAT
    frame_chat = Frame(root)
    chat_label = Text(frame_chat, bg="white", height=22)
    chat_label.pack(side=LEFT)
    chat_label.insert(END, "Welcome!")
    chat_label.config(state=DISABLED)
    scroll_chat = Scrollbar(frame_chat)
    scroll_chat.pack(side=RIGHT, fill=Y)
    scroll_chat.config(command=chat_label.yview)
    chat_label.config(yscrollcommand=scroll_chat.set)
    frame_chat.pack()
    # Frame INPUT
    frame_input = Frame(root)
    frame_input.pack(side=BOTTOM, fill=X)
    label = Label(frame_input, text="Your message:")
    label.pack(side=LEFT)
    chat_text = StringVar()
    chat_input = Entry(frame_input, textvariable=chat_text)
    chat_input.focus_set()
    chat_input.bind("<Return>", input_chat)
    chat_input.pack(fill=X)
    menu = Menu()
    root.config(menu=menu)
    menu.add_command(label="connect", command=open_connect)
    menu.add_command(label="getsize", command=lambda: get_size(root))
    threading.Thread(target=listener, args=(sock,)).start()
    root.mainloop()
